Έστω ότι έχουμε στη διάθεσή μας
έναν επεξεργαστή που διαθέτει N καταχωρητές R1, R2, ..., RN οι οποίοι έχουν δακτυλιοειδή διευθέτηση. Αυτό σημαίνει ότι μπορεί κάποιος να μεταφέρει τα περιεχόμενα του καταχωρητή Ri στον καταχωρητή Ri+1, για 1  i < N, και του RN στον R1 με τις εντολές move(i), για 1  i < N, και move(N), αντίστοιχα. Επίσης, μπορεί να αντιμεταθέσει τα περιεχόμενα των καταχωρητών Ri και Rj με την εντολή swap(i,j), όπου i < j. Έστω, τώρα, ότι σας δίνονται τα αρχικά περιεχόμενα των N καταχωρητών, καθώς και τα επιθυμητά τελικά περιεχόμενα. Το ζητούμενο είναι να βρεθεί η μικρότερη αλληλουχία από τις εντολές move και swap που πρέπει να εκτελεσθούν για να επιτευχθεί ο ζητούμενος μετασχηματισμός. Συγκεκριμένα, ορίζεται το κατηγόρημα codegen/3, έτσι ώστε όταν αυτό καλείται με πρώτο όρισμα τη λίστα των αρχικών περιεχομένων των καταχωρητών και με δεύτερο όρισμα τη λίστα των τελικών περιεχομένων, να επιστρέφει στο τρίτο όρισμα τη λίστα των απαραίτητων (ελάχιστων) εντολών που απαιτούνται για το μετασχηματισμό. Σημειώστε ότι είναι δυνατόν στην αναπαράσταση των περιεχομένων των καταχωρητών να έχουμε, τόσο στην αρχική όσο και στην τελική κατάσταση, το σύμβολο \*, που σημαίνει, για μεν την αρχική κατάσταση "δεν ξέρω τι περιέχεται στον καταχωρητή", για δε την τελική κατάσταση "δεν με ενδιαφέρει τι περιέχεται στον καταχωρητή".<br>
Κάποια παραδείγματα εκτέλεσης είναι τα εξής:<br>
?- codegen([a,b,c,d],[a,d,a,b],L).<br>
L = [move(2),move(1),swap(3,4),swap(2,3)]<br><br>
?- codegen([a,\*,c],[c,a,\*],L).<br>
L = [move(1),move(3)]<br>